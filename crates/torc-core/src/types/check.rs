//! Type compatibility checking.
//!
//! Implements the five type checking modes from the Torc spec (section 4):
//! consistency (edge type compatibility), linearity, effects, resources,
//! and refinement (proof obligation generation).

use thiserror::Error;

use crate::contract::{ObligationKind, ProofObligation, ProofStatus};
use crate::types::{Linearity, Predicate, Type, ValueParam};

/// Errors produced by the type compatibility checker.
#[derive(Debug, Error)]
pub enum TypeError {
    #[error("incompatible types: expected {expected}, found {found} ({context})")]
    IncompatibleTypes {
        expected: String,
        found: String,
        context: String,
    },

    #[error("linearity mismatch: expected {expected:?}, found {found:?}")]
    LinearityMismatch {
        expected: Linearity,
        found: Linearity,
    },

    #[error("resource bound exceeded: {kind} — {detail}")]
    ResourceBoundExceeded { kind: &'static str, detail: String },

    #[error("unresolved named type: {0}")]
    UnresolvedNamedType(String),
}

/// Check if `source` linearity can satisfy `target` linearity requirement.
///
/// Subtyping lattice:
///   Linear  ≤ Affine  ≤ Unrestricted
///   Unique  ≤ Shared  ≤ Unrestricted
///   Counted ≤ Unrestricted
///   anything ≤ Unrestricted
pub fn linearity_compatible(source: Linearity, target: Linearity) -> bool {
    if source == target {
        return true;
    }
    match target {
        Linearity::Unrestricted => true,
        Linearity::Affine => source == Linearity::Linear,
        Linearity::Shared => source == Linearity::Unique,
        _ => false,
    }
}

/// Check if `source` type is assignable to `target` type.
///
/// Returns proof obligations generated by refinement/dependent subtyping.
/// Named types must be resolved before calling this function.
pub fn types_compatible(source: &Type, target: &Type) -> Result<Vec<ProofObligation>, TypeError> {
    // Named types must be resolved before checking
    if let Type::Named(name) = source {
        return Err(TypeError::UnresolvedNamedType(name.clone()));
    }
    if let Type::Named(name) = target {
        return Err(TypeError::UnresolvedNamedType(name.clone()));
    }

    let mut obligations = Vec::new();
    check_compatible(source, target, &mut obligations)?;
    Ok(obligations)
}

fn check_compatible(
    source: &Type,
    target: &Type,
    obligations: &mut Vec<ProofObligation>,
) -> Result<(), TypeError> {
    match (source, target) {
        // === Primitives: exact match only ===
        (Type::Void, Type::Void) | (Type::Unit, Type::Unit) | (Type::Bool, Type::Bool) => Ok(()),

        (
            Type::Int {
                width: sw,
                signedness: ss,
            },
            Type::Int {
                width: tw,
                signedness: ts,
            },
        ) => {
            if sw == tw && ss == ts {
                Ok(())
            } else {
                Err(incompatible(
                    source,
                    target,
                    "integer width or signedness mismatch",
                ))
            }
        }

        (Type::Float { precision: sp }, Type::Float { precision: tp }) => {
            if sp == tp {
                Ok(())
            } else {
                Err(incompatible(source, target, "float precision mismatch"))
            }
        }

        (
            Type::Fixed {
                total_bits: st,
                frac_bits: sf,
            },
            Type::Fixed {
                total_bits: tt,
                frac_bits: tf,
            },
        ) => {
            if st == tt && sf == tf {
                Ok(())
            } else {
                Err(incompatible(source, target, "fixed-point format mismatch"))
            }
        }

        // === Composites: structural compatibility ===
        (Type::Tuple(src_elems), Type::Tuple(tgt_elems)) => {
            if src_elems.len() != tgt_elems.len() {
                return Err(incompatible(source, target, "tuple length mismatch"));
            }
            for (s, t) in src_elems.iter().zip(tgt_elems.iter()) {
                check_compatible(s, t, obligations)?;
            }
            Ok(())
        }

        (Type::Record(src_fields), Type::Record(tgt_fields)) => {
            if src_fields.len() != tgt_fields.len() {
                return Err(incompatible(source, target, "record field count mismatch"));
            }
            for (name, tgt_ty) in tgt_fields {
                match src_fields.get(name) {
                    Some(src_ty) => check_compatible(src_ty, tgt_ty, obligations)?,
                    None => {
                        return Err(incompatible(
                            source,
                            target,
                            &format!("missing field '{name}'"),
                        ))
                    }
                }
            }
            Ok(())
        }

        (Type::Variant(src_cases), Type::Variant(tgt_cases)) => {
            if src_cases.len() != tgt_cases.len() {
                return Err(incompatible(source, target, "variant case count mismatch"));
            }
            for (tag, tgt_ty) in tgt_cases {
                match src_cases.get(tag) {
                    Some(src_ty) => check_compatible(src_ty, tgt_ty, obligations)?,
                    None => {
                        return Err(incompatible(
                            source,
                            target,
                            &format!("missing variant case '{tag}'"),
                        ))
                    }
                }
            }
            Ok(())
        }

        (
            Type::Array {
                element: se,
                length: sl,
            },
            Type::Array {
                element: te,
                length: tl,
            },
        ) => {
            if sl != tl {
                return Err(incompatible(source, target, "array length mismatch"));
            }
            check_compatible(se, te, obligations)
        }

        (Type::Vec { element: se }, Type::Vec { element: te }) => {
            check_compatible(se, te, obligations)
        }

        // === Refinement: generates proof obligation ===
        (
            Type::Refined {
                base: sb,
                predicate: sp,
            },
            Type::Refined {
                base: tb,
                predicate: tp,
            },
        ) => {
            check_compatible(sb, tb, obligations)?;
            // Source predicate must imply target predicate
            obligations.push(ProofObligation {
                kind: ObligationKind::TypeRefinement,
                predicate: Predicate::Implies(Box::new(sp.clone()), Box::new(tp.clone())),
                description: "refinement subtyping: source predicate must imply target predicate"
                    .to_string(),
                status: ProofStatus::Pending,
                witness: None,
                waiver: None,
            });
            Ok(())
        }

        // Unrefined assignable to refined: base must match, generates obligation
        // that `true` implies the target predicate (always the target predicate).
        (
            src,
            Type::Refined {
                base: tb,
                predicate: tp,
            },
        ) if !matches!(src, Type::Refined { .. }) => {
            check_compatible(src, tb, obligations)?;
            obligations.push(ProofObligation {
                kind: ObligationKind::TypeRefinement,
                predicate: tp.clone(),
                description: "unrefined source must satisfy target refinement".to_string(),
                status: ProofStatus::Pending,
                witness: None,
                waiver: None,
            });
            Ok(())
        }

        // Refined assignable to unrefined: just check base types.
        (Type::Refined { base: sb, .. }, tgt) if !matches!(tgt, Type::Refined { .. }) => {
            check_compatible(sb, tgt, obligations)
        }

        // === Linearity: subtyping lattice ===
        (
            Type::Linear {
                inner: si,
                linearity: sl,
            },
            Type::Linear {
                inner: ti,
                linearity: tl,
            },
        ) => {
            if !linearity_compatible(*sl, *tl) {
                return Err(TypeError::LinearityMismatch {
                    expected: *tl,
                    found: *sl,
                });
            }
            check_compatible(si, ti, obligations)
        }

        // === Resource types: covariant on inner, bound constraints ===
        (
            Type::Timed {
                inner: si,
                bound: sb,
            },
            Type::Timed {
                inner: ti,
                bound: tb,
            },
        ) => {
            check_compatible(si, ti, obligations)?;
            // Source bound must be ≤ target bound (faster satisfies slower requirement)
            if sb.wcet_ns > tb.wcet_ns {
                return Err(TypeError::ResourceBoundExceeded {
                    kind: "Timed",
                    detail: format!(
                        "source WCET {}ns exceeds target WCET {}ns",
                        sb.wcet_ns, tb.wcet_ns
                    ),
                });
            }
            Ok(())
        }

        (
            Type::Sized {
                inner: si,
                max_bytes: sb,
            },
            Type::Sized {
                inner: ti,
                max_bytes: tb,
            },
        ) => {
            check_compatible(si, ti, obligations)?;
            // Source size must be ≤ target size (smaller fits where bigger allowed)
            if sb > tb {
                return Err(TypeError::ResourceBoundExceeded {
                    kind: "Sized",
                    detail: format!("source size {}B exceeds target size {}B", sb, tb),
                });
            }
            Ok(())
        }

        (
            Type::Powered {
                inner: si,
                energy_uj: se,
            },
            Type::Powered {
                inner: ti,
                energy_uj: te,
            },
        ) => {
            check_compatible(si, ti, obligations)?;
            // Source energy must be ≤ target energy
            if se > te {
                return Err(TypeError::ResourceBoundExceeded {
                    kind: "Powered",
                    detail: format!("source energy {}μJ exceeds target energy {}μJ", se, te),
                });
            }
            Ok(())
        }

        (
            Type::Bandwidth {
                inner: si,
                min_bps: sb,
            },
            Type::Bandwidth {
                inner: ti,
                min_bps: tb,
            },
        ) => {
            check_compatible(si, ti, obligations)?;
            // Source throughput must be ≥ target throughput (more satisfies less)
            if sb < tb {
                return Err(TypeError::ResourceBoundExceeded {
                    kind: "Bandwidth",
                    detail: format!("source throughput {}Bps below target minimum {}Bps", sb, tb),
                });
            }
            Ok(())
        }

        // === Probability types ===
        (Type::Distribution(si), Type::Distribution(ti)) => check_compatible(si, ti, obligations),

        (
            Type::Posterior {
                inner: si,
                evidence: se,
            },
            Type::Posterior {
                inner: ti,
                evidence: te,
            },
        ) => {
            if se != te {
                return Err(incompatible(source, target, "posterior evidence mismatch"));
            }
            check_compatible(si, ti, obligations)
        }

        (
            Type::Interval {
                inner: si,
                confidence: sc,
            },
            Type::Interval {
                inner: ti,
                confidence: tc,
            },
        ) => {
            if (sc - tc).abs() > f64::EPSILON {
                return Err(incompatible(source, target, "interval confidence mismatch"));
            }
            check_compatible(si, ti, obligations)
        }

        (
            Type::Approximate {
                inner: si,
                max_error: se,
            },
            Type::Approximate {
                inner: ti,
                max_error: te,
            },
        ) => {
            if (se - te).abs() > f64::EPSILON {
                return Err(incompatible(
                    source,
                    target,
                    "approximate error bound mismatch",
                ));
            }
            check_compatible(si, ti, obligations)
        }

        // === Dependent types ===
        (
            Type::Parameterized {
                name: sn,
                type_params: stp,
                value_params: svp,
            },
            Type::Parameterized {
                name: tn,
                type_params: ttp,
                value_params: tvp,
            },
        ) => {
            if sn != tn {
                return Err(incompatible(
                    source,
                    target,
                    "parameterized type name mismatch",
                ));
            }
            if stp.len() != ttp.len() {
                return Err(incompatible(
                    source,
                    target,
                    "type parameter count mismatch",
                ));
            }
            if svp.len() != tvp.len() {
                return Err(incompatible(
                    source,
                    target,
                    "value parameter count mismatch",
                ));
            }
            for (s, t) in stp.iter().zip(ttp.iter()) {
                check_compatible(s, t, obligations)?;
            }
            for (s, t) in svp.iter().zip(tvp.iter()) {
                match (s, t) {
                    (ValueParam::Concrete(sv), ValueParam::Concrete(tv)) => {
                        if sv != tv {
                            return Err(incompatible(
                                source,
                                target,
                                &format!("value parameter mismatch: {sv} vs {tv}"),
                            ));
                        }
                    }
                    // Symbolic params generate equality obligations
                    _ => {
                        let s_pred = value_param_to_predicate(s);
                        let t_pred = value_param_to_predicate(t);
                        obligations.push(ProofObligation {
                            kind: ObligationKind::TypeRefinement,
                            predicate: Predicate::Eq(Box::new(s_pred), Box::new(t_pred)),
                            description: "dependent type value parameters must be equal"
                                .to_string(),
                            status: ProofStatus::Pending,
                            witness: None,
                            waiver: None,
                        });
                    }
                }
            }
            Ok(())
        }

        // === Option type ===
        (Type::Option(si), Type::Option(ti)) => check_compatible(si, ti, obligations),

        // === Named: should have been resolved ===
        (Type::Named(name), _) | (_, Type::Named(name)) => {
            Err(TypeError::UnresolvedNamedType(name.clone()))
        }

        // === Fallthrough: incompatible ===
        _ => Err(incompatible(source, target, "different type kinds")),
    }
}

fn incompatible(source: &Type, target: &Type, context: &str) -> TypeError {
    TypeError::IncompatibleTypes {
        expected: format!("{target}"),
        found: format!("{source}"),
        context: context.to_string(),
    }
}

fn value_param_to_predicate(vp: &ValueParam) -> Predicate {
    match vp {
        ValueParam::Concrete(v) => Predicate::IntLit(*v),
        ValueParam::Symbolic(s) => Predicate::Var(s.clone()),
    }
}

#[cfg(test)]
mod tests {
    use std::collections::BTreeMap;

    use super::*;
    use crate::types::TimeBound;

    #[test]
    fn primitive_exact_match() {
        let result = types_compatible(&Type::i32(), &Type::i32());
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty());
    }

    #[test]
    fn primitive_width_mismatch() {
        let result = types_compatible(&Type::i32(), &Type::i64());
        assert!(result.is_err());
    }

    #[test]
    fn primitive_signedness_mismatch() {
        let result = types_compatible(&Type::i32(), &Type::u32());
        assert!(result.is_err());
    }

    #[test]
    fn composite_tuple_compatible() {
        let src = Type::Tuple(vec![Type::i32(), Type::f32()]);
        let tgt = Type::Tuple(vec![Type::i32(), Type::f32()]);
        assert!(types_compatible(&src, &tgt).is_ok());
    }

    #[test]
    fn composite_tuple_length_mismatch() {
        let src = Type::Tuple(vec![Type::i32()]);
        let tgt = Type::Tuple(vec![Type::i32(), Type::f32()]);
        assert!(types_compatible(&src, &tgt).is_err());
    }

    #[test]
    fn composite_record_field_mismatch() {
        let src = BTreeMap::from([
            ("x".to_string(), Type::i32()),
            ("y".to_string(), Type::i32()),
        ]);
        let tgt = BTreeMap::from([
            ("x".to_string(), Type::i32()),
            ("z".to_string(), Type::i32()),
        ]);
        assert!(types_compatible(&Type::Record(src), &Type::Record(tgt)).is_err());
    }

    #[test]
    fn refinement_generates_obligation() {
        let src = Type::i32().refined(Predicate::positive("value"));
        let tgt = Type::i32().refined(Predicate::in_range("value", 0, 100));
        let result = types_compatible(&src, &tgt).unwrap();
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].kind, ObligationKind::TypeRefinement);
        assert!(matches!(result[0].predicate, Predicate::Implies(..)));
    }

    #[test]
    fn linearity_subtyping() {
        // Linear assignable to Affine
        let src = Type::i32().with_linearity(Linearity::Linear);
        let tgt = Type::i32().with_linearity(Linearity::Affine);
        assert!(types_compatible(&src, &tgt).is_ok());

        // Affine NOT assignable to Linear
        let src = Type::i32().with_linearity(Linearity::Affine);
        let tgt = Type::i32().with_linearity(Linearity::Linear);
        assert!(types_compatible(&src, &tgt).is_err());
    }

    #[test]
    fn linearity_anything_to_unrestricted() {
        for lin in [
            Linearity::Linear,
            Linearity::Affine,
            Linearity::Shared,
            Linearity::Unique,
            Linearity::Counted,
        ] {
            let src = Type::i32().with_linearity(lin);
            let tgt = Type::i32().with_linearity(Linearity::Unrestricted);
            assert!(
                types_compatible(&src, &tgt).is_ok(),
                "{lin:?} should be assignable to Unrestricted"
            );
        }
    }

    #[test]
    fn resource_timed_covariant() {
        // Faster satisfies slower requirement
        let src = Type::Timed {
            inner: Box::new(Type::f32()),
            bound: TimeBound {
                wcet_ns: 100,
                target: "arm".to_string(),
            },
        };
        let tgt = Type::Timed {
            inner: Box::new(Type::f32()),
            bound: TimeBound {
                wcet_ns: 200,
                target: "arm".to_string(),
            },
        };
        assert!(types_compatible(&src, &tgt).is_ok());
    }

    #[test]
    fn resource_timed_violation() {
        // Slower does NOT satisfy faster requirement
        let src = Type::Timed {
            inner: Box::new(Type::f32()),
            bound: TimeBound {
                wcet_ns: 300,
                target: "arm".to_string(),
            },
        };
        let tgt = Type::Timed {
            inner: Box::new(Type::f32()),
            bound: TimeBound {
                wcet_ns: 200,
                target: "arm".to_string(),
            },
        };
        assert!(types_compatible(&src, &tgt).is_err());
    }

    #[test]
    fn resource_sized_covariant() {
        // Smaller satisfies larger bound
        let src = Type::Sized {
            inner: Box::new(Type::i32()),
            max_bytes: 4,
        };
        let tgt = Type::Sized {
            inner: Box::new(Type::i32()),
            max_bytes: 8,
        };
        assert!(types_compatible(&src, &tgt).is_ok());

        // Larger does NOT satisfy smaller bound
        let src2 = Type::Sized {
            inner: Box::new(Type::i32()),
            max_bytes: 16,
        };
        assert!(types_compatible(&src2, &tgt).is_err());
    }

    #[test]
    fn resource_bandwidth_covariant() {
        // Higher throughput satisfies lower requirement
        let src = Type::Bandwidth {
            inner: Box::new(Type::u8()),
            min_bps: 1_000_000,
        };
        let tgt = Type::Bandwidth {
            inner: Box::new(Type::u8()),
            min_bps: 500_000,
        };
        assert!(types_compatible(&src, &tgt).is_ok());

        // Lower throughput does NOT satisfy higher requirement
        let src2 = Type::Bandwidth {
            inner: Box::new(Type::u8()),
            min_bps: 100_000,
        };
        assert!(types_compatible(&src2, &tgt).is_err());
    }

    #[test]
    fn resource_powered_covariant() {
        // Lower energy satisfies higher budget
        let src = Type::Powered {
            inner: Box::new(Type::f32()),
            energy_uj: 50,
        };
        let tgt = Type::Powered {
            inner: Box::new(Type::f32()),
            energy_uj: 100,
        };
        assert!(types_compatible(&src, &tgt).is_ok());

        // Higher energy does NOT satisfy lower budget
        let src2 = Type::Powered {
            inner: Box::new(Type::f32()),
            energy_uj: 200,
        };
        assert!(types_compatible(&src2, &tgt).is_err());
    }

    #[test]
    fn dependent_params_match() {
        let src = Type::Parameterized {
            name: "Matrix".to_string(),
            type_params: vec![Type::f32()],
            value_params: vec![ValueParam::Concrete(3), ValueParam::Concrete(4)],
        };
        let tgt = Type::Parameterized {
            name: "Matrix".to_string(),
            type_params: vec![Type::f32()],
            value_params: vec![ValueParam::Concrete(3), ValueParam::Concrete(4)],
        };
        assert!(types_compatible(&src, &tgt).is_ok());
    }

    #[test]
    fn dependent_params_mismatch() {
        let src = Type::Parameterized {
            name: "Matrix".to_string(),
            type_params: vec![Type::f32()],
            value_params: vec![ValueParam::Concrete(3), ValueParam::Concrete(4)],
        };
        let tgt = Type::Parameterized {
            name: "Matrix".to_string(),
            type_params: vec![Type::f32()],
            value_params: vec![ValueParam::Concrete(4), ValueParam::Concrete(3)],
        };
        assert!(types_compatible(&src, &tgt).is_err());
    }

    #[test]
    fn named_type_errors() {
        let src = Type::Named("Foo".to_string());
        let tgt = Type::i32();
        assert!(matches!(
            types_compatible(&src, &tgt),
            Err(TypeError::UnresolvedNamedType(name)) if name == "Foo"
        ));
    }

    #[test]
    fn option_compatible() {
        let src = Type::Option(Box::new(Type::i32()));
        let tgt = Type::Option(Box::new(Type::i32()));
        assert!(types_compatible(&src, &tgt).is_ok());
    }

    #[test]
    fn option_inner_mismatch() {
        let src = Type::Option(Box::new(Type::i32()));
        let tgt = Type::Option(Box::new(Type::f64()));
        assert!(types_compatible(&src, &tgt).is_err());
    }

    #[test]
    fn linearity_compatible_lattice() {
        // Same
        assert!(linearity_compatible(Linearity::Linear, Linearity::Linear));
        // Linear ≤ Affine
        assert!(linearity_compatible(Linearity::Linear, Linearity::Affine));
        // Affine NOT ≤ Linear
        assert!(!linearity_compatible(Linearity::Affine, Linearity::Linear));
        // Unique ≤ Shared
        assert!(linearity_compatible(Linearity::Unique, Linearity::Shared));
        // Shared NOT ≤ Unique
        assert!(!linearity_compatible(Linearity::Shared, Linearity::Unique));
        // Everything ≤ Unrestricted
        assert!(linearity_compatible(
            Linearity::Counted,
            Linearity::Unrestricted
        ));
    }
}
