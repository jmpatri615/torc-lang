//! Torc-to-C header generation.
//!
//! Generates C header files from Torc graph nodes that have `export.name` annotations.
//! Contracts are emitted as documentation comments.

use torc_core::graph::Graph;

use crate::error::Result;
use crate::marshal::ctype_string_from_torc;

/// An exported function extracted from a Torc graph.
#[derive(Debug)]
struct ExportedFunction {
    name: String,
    return_type: String,
    parameters: Vec<(String, String)>, // (type, name)
    contract_comment: Option<String>,
}

/// Generate a C header file from a Torc graph's exported functions.
///
/// Finds nodes with `export.name` annotations and converts their type signatures
/// to C declarations. Contracts are included as doc comments.
pub fn generate_c_header(graph: &Graph, guard_name: &str) -> Result<String> {
    let exports = collect_exports(graph);

    let mut out = String::new();

    // Header guard
    let guard = guard_name
        .to_uppercase()
        .replace(['-', '.'], "_");
    out.push_str(&format!("#ifndef {guard}_H\n"));
    out.push_str(&format!("#define {guard}_H\n\n"));

    // Standard includes
    out.push_str("#include <stdint.h>\n");
    out.push_str("#include <stdbool.h>\n\n");

    // Auto-generated notice
    out.push_str("/* Generated by torc-ffi — do not edit manually. */\n\n");

    out.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");

    // Function declarations
    for export in &exports {
        // Contract as doc comment
        if let Some(comment) = &export.contract_comment {
            out.push_str("/*\n");
            for line in comment.lines() {
                out.push_str(&format!(" * {line}\n"));
            }
            out.push_str(" */\n");
        }

        // Function signature
        out.push_str(&export.return_type);
        out.push(' ');
        out.push_str(&export.name);
        out.push('(');

        if export.parameters.is_empty() {
            out.push_str("void");
        } else {
            for (i, (ty, name)) in export.parameters.iter().enumerate() {
                if i > 0 {
                    out.push_str(", ");
                }
                out.push_str(ty);
                if !name.is_empty() {
                    out.push(' ');
                    out.push_str(name);
                }
            }
        }

        out.push_str(");\n\n");
    }

    out.push_str("#ifdef __cplusplus\n}\n#endif\n\n");
    out.push_str(&format!("#endif /* {guard}_H */\n"));

    Ok(out)
}

/// Collect exported functions from a graph.
fn collect_exports(graph: &Graph) -> Vec<ExportedFunction> {
    let mut exports = Vec::new();

    for node in graph.nodes() {
        let export_name = match node.annotations.get("export.name") {
            Some(name) => name.clone(),
            None => continue,
        };

        let type_sig = match &node.type_signature {
            Some(sig) => sig,
            None => continue,
        };

        // Convert return type
        let return_type = if type_sig.outputs.is_empty() {
            "void".to_string()
        } else {
            ctype_string_from_torc(&type_sig.outputs[0])
        };

        // Convert parameters
        let parameters: Vec<(String, String)> = type_sig
            .inputs
            .iter()
            .enumerate()
            .map(|(i, ty)| {
                let c_type = ctype_string_from_torc(ty);
                let param_name = node
                    .annotations
                    .get(&format!("export.param.{i}"))
                    .cloned()
                    .unwrap_or_default();
                (c_type, param_name)
            })
            .collect();

        // Build contract comment from contract
        let contract_comment = node.contract.as_ref().map(|c| {
            let mut comment = format!("Contract for {export_name}:");
            if !c.preconditions.is_empty() {
                comment.push_str("\n  Preconditions:");
                for pre in &c.preconditions {
                    comment.push_str(&format!("\n    - {pre:?}"));
                }
            }
            if !c.postconditions.is_empty() {
                comment.push_str("\n  Postconditions:");
                for post in &c.postconditions {
                    comment.push_str(&format!("\n    - {post:?}"));
                }
            }
            if !c.effects.is_pure() {
                comment.push_str("\n  Effects: ");
                let effects: Vec<_> = c.effects.effects.iter().map(|e| format!("{e:?}")).collect();
                comment.push_str(&effects.join(", "));
            }
            comment
        });

        exports.push(ExportedFunction {
            name: export_name,
            return_type,
            parameters,
            contract_comment,
        });
    }

    exports
}

#[cfg(test)]
mod tests {
    use super::*;
    use torc_core::builder::GraphBuilder;
    use torc_core::contract::{Contract, EffectSet};
    use torc_core::graph::node::{ArithmeticOp, NodeKind};
    use torc_core::types::{Predicate, Type, TypeSignature};

    fn make_export_graph() -> Graph {
        let mut builder = GraphBuilder::new();

        // An exported function: int32_t add(int32_t a, int32_t b)
        let add_id = builder.add_typed_node(
            NodeKind::Arithmetic(ArithmeticOp::Add),
            "add",
            TypeSignature::pure_fn(vec![Type::i32(), Type::i32()], Type::i32()),
        );
        builder.annotate(add_id, "export.name", "torc_add").unwrap();
        builder.annotate(add_id, "export.param.0", "a").unwrap();
        builder.annotate(add_id, "export.param.1", "b").unwrap();

        builder.into_graph()
    }

    #[test]
    fn simple_header() {
        let graph = make_export_graph();
        let header = generate_c_header(&graph, "my_module").unwrap();

        assert!(header.contains("#ifndef MY_MODULE_H"));
        assert!(header.contains("#define MY_MODULE_H"));
        assert!(header.contains("#endif /* MY_MODULE_H */"));
        assert!(header.contains("int32_t torc_add(int32_t a, int32_t b);"));
        assert!(header.contains("#include <stdint.h>"));
    }

    #[test]
    fn contract_docs_in_header() {
        let mut builder = GraphBuilder::new();

        let contract = Contract::with_conditions(
            vec![Predicate::Ge(
                Box::new(Predicate::Var("x".to_string())),
                Box::new(Predicate::IntLit(0)),
            )],
            vec![Predicate::Ge(
                Box::new(Predicate::Var("result".to_string())),
                Box::new(Predicate::IntLit(0)),
            )],
        )
        .with_effects(EffectSet::pure_set());

        let id = builder.add_full_node(
            NodeKind::Arithmetic(ArithmeticOp::Add),
            "abs",
            Some(TypeSignature::pure_fn(vec![Type::i32()], Type::i32())),
            Some(contract),
            None,
        );
        builder.annotate(id, "export.name", "torc_abs").unwrap();

        let graph = builder.into_graph();
        let header = generate_c_header(&graph, "abs_module").unwrap();

        assert!(header.contains("Contract for torc_abs:"));
        assert!(header.contains("Preconditions:"));
        assert!(header.contains("Postconditions:"));
    }

    #[test]
    fn header_guard_sanitized() {
        let graph = make_export_graph();
        let header = generate_c_header(&graph, "my-module.v2").unwrap();
        assert!(header.contains("#ifndef MY_MODULE_V2_H"));
    }

    #[test]
    fn missing_export_annotation() {
        // Graph with no export annotations → empty header body
        let mut builder = GraphBuilder::new();
        builder.add_typed_node(
            NodeKind::Literal,
            "lit",
            TypeSignature::source(Type::i32()),
        );
        let graph = builder.into_graph();
        let header = generate_c_header(&graph, "empty").unwrap();

        // Should still have guard and includes, but no function declarations
        assert!(header.contains("#ifndef EMPTY_H"));
        assert!(!header.contains(");"));
    }

    #[test]
    fn multiple_exports() {
        let mut builder = GraphBuilder::new();

        let id1 = builder.add_typed_node(
            NodeKind::Arithmetic(ArithmeticOp::Add),
            "add",
            TypeSignature::pure_fn(vec![Type::i32(), Type::i32()], Type::i32()),
        );
        builder.annotate(id1, "export.name", "torc_add").unwrap();

        let id2 = builder.add_typed_node(
            NodeKind::Arithmetic(ArithmeticOp::Mul),
            "mul",
            TypeSignature::pure_fn(vec![Type::f64(), Type::f64()], Type::f64()),
        );
        builder.annotate(id2, "export.name", "torc_mul").unwrap();

        let graph = builder.into_graph();
        let header = generate_c_header(&graph, "math_ops").unwrap();

        assert!(header.contains("torc_add"));
        assert!(header.contains("torc_mul"));
    }
}
