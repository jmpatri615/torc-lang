# 9. Human Observability Layer

## Why Observability Is Mandatory

Torc programs are binary graphs that no human can read directly. Without a robust observability layer, Torc would be an opaque black box — unacceptable for any system where humans bear responsibility for correctness, safety, or regulatory compliance.

The observability layer is not a debugging tool added after the fact. It is a core component of the language specification. Every compliant Torc implementation must provide the full set of projection views defined here.

## Projection Views

A projection view is a human-comprehensible representation of some aspect of a Torc program graph. Different views serve different audiences and purposes.

### Dataflow View

**Audience:** System architects, integration engineers
**Purpose:** Understand the structure and data flow of the program

Renders the program graph as a visual diagram:

- Nodes displayed as boxes with type signatures
- Edges displayed as directed arrows with data types
- Regions displayed as colored boundaries
- Parallelism visible as width (nodes at the same graph depth execute concurrently)
- Critical path highlighted

Interactive features:
- Collapse/expand regions for hierarchical navigation
- Click a node to see its contract, provenance, and connections
- Filter by effect type (show only I/O nodes, only pure computation, etc.)
- Search by type, contract property, or provenance

### Contract View

**Audience:** Safety engineers, verification engineers
**Purpose:** Review behavioral guarantees without reading code

Presents a structured table of all contracts in the program:

```
┌────────────────────┬──────────────────────────┬───────────────────┬──────────┐
│ Node               │ Key Contracts            │ Resource Bounds   │ Status   │
├────────────────────┼──────────────────────────┼───────────────────┼──────────┤
│ read_sensor        │ output in [0.0, 5.0]     │ WCET: 12μs       │ Verified │
│                    │ monotonic sampling        │ Stack: 32B       │          │
│                    │ effects: IO<ADC>          │ Heap: 0          │          │
├────────────────────┼──────────────────────────┼───────────────────┼──────────┤
│ pid_compute        │ output in [min, max]     │ WCET: 8μs        │ Verified │
│                    │ bounded integrator        │ Stack: 128B      │          │
│                    │ effects: Pure             │ Heap: 0          │          │
├────────────────────┼──────────────────────────┼───────────────────┼──────────┤
│ can_transmit       │ frame.dlc <= 8           │ WCET: 45μs       │ Verified │
│                    │ effects: IO<CAN1>        │ Stack: 64B       │          │
│                    │ failure: CAN_BUS_OFF     │ Heap: 0          │          │
│                    │   recovery: retry(3)     │                   │          │
└────────────────────┴──────────────────────────┴───────────────────┴──────────┘
```

Sortable and filterable by any column. Contracts can be traced back to requirements documents through provenance links.

### Resource Budget View

**Audience:** Embedded engineers, performance engineers
**Purpose:** Understand resource utilization and margins

```
Target: STM32F407 Discovery @ 168MHz

MEMORY
  Flash:  48,832 / 1,048,576 bytes  ████░░░░░░░░░░░░░░░░  4.7%
  SRAM:    3,412 /   131,072 bytes  █░░░░░░░░░░░░░░░░░░░  2.6%
  CCM:         0 /    65,536 bytes  ░░░░░░░░░░░░░░░░░░░░  0.0%
  Stack:   1,024 /     4,096 bytes  █████░░░░░░░░░░░░░░░  25.0%

TIMING (worst-case at 168MHz)
  Main loop:         847μs / 1,000μs budget  █████████████████░░░  84.7%
    ├─ read_sensor:   12μs                   █░░░░░░░░░░░░░░░░░░░
    ├─ pid_compute:    8μs                   █░░░░░░░░░░░░░░░░░░░
    ├─ safety_check:  23μs                   █░░░░░░░░░░░░░░░░░░░
    ├─ can_transmit:  45μs                   █░░░░░░░░░░░░░░░░░░░
    └─ [scheduling]:   4μs                   ░░░░░░░░░░░░░░░░░░░░
  ADC ISR:            12μs /    50μs budget  █████░░░░░░░░░░░░░░░  24.0%
  CAN ISR:            18μs /    50μs budget  ████████░░░░░░░░░░░░  36.0%

PERIPHERALS
  ADC1: claimed by read_sensor (exclusive)
  CAN1: claimed by can_transmit (exclusive)
  TIM2: claimed by main_loop_trigger (exclusive)
  UART2: unclaimed
```

### Pseudo-Code View

**Audience:** Developers, code reviewers
**Purpose:** Approximate understanding of algorithmic logic

Generates a lossy but readable approximation of the program in a procedural style. This is explicitly marked as an approximation — the actual program may execute differently due to parallelism, reordering, and target-specific optimizations.

```torc-projection
// APPROXIMATION — actual execution may differ
// Generated by: torc inspect --view pseudo-code --module main_loop

fn main_loop() {
    // Contracts: WCET <= 1000μs, stack <= 1024B, heap == 0
    // Effects: IO<ADC1, CAN1, TIM2>

    let raw_voltage = read_sensor(ADC1, channel=0)
        // -> Float32 in [0.0, 5.0], WCET 12μs

    let scaled = scale_input(raw_voltage, config.sensor_range)
        // -> Float32, Pure, WCET 2μs

    let (output, new_state) = pid_compute(
        setpoint = config.target,
        measurement = scaled,
        dt = 0.001,
        state = pid_state,
        config = config.pid,
    )  // -> Float32 in [config.out_min, config.out_max], Pure, WCET 8μs

    let safe_output = safety_check(output, scaled, config.safety)
        // -> Float32, may clamp or override, WCET 23μs

    apply_output(PWM_TIM1, safe_output)
        // -> Unit, IO<TIM1>, WCET 3μs

    transmit_status(CAN1, scaled, safe_output, pid_state)
        // -> Unit, IO<CAN1>, WCET 45μs
}
```

### Provenance View

**Audience:** Auditors, certification engineers
**Purpose:** Trace the origin and rationale of every decision

```
Node: pid_compute (uuid: 7a3f...)
  Created: 2026-02-15T10:30:00Z
  Author:  claude-4.5-opus (Anthropic)
  Reason:  "Implement PID controller per requirement REQ-CTRL-001"
  Derived from:
    - Requirement: REQ-CTRL-001 (linked)
    - Algorithm: parallel-form PID with trapezoidal integration
    - Anti-windup: clamping method per REQ-CTRL-003
  Modified:
    - 2026-02-15T14:00:00Z: "Increased integrator bound from 100 to 200
      to accommodate revised operating range per REQ-CTRL-001-rev2"
    - Author: claude-4.5-opus
  Verification:
    - All 23 proof obligations verified
    - Verification time: 1.2s
    - Solver: Z3 4.13.0
```

### Variant View

**Audience:** Product line engineers, configuration managers
**Purpose:** Understand the variant space and configuration impact

```
Configuration Space: 3 variant dimensions, 12 valid combinations

  Dimension 1: SENSOR_TYPE = {analog_5v, analog_10v, digital_spi}
  Dimension 2: CAN_PROTOCOL = {raw_can, j1939, uds}
  Dimension 3: SAFETY_LEVEL = {qm, asil_b, asil_d}

  Constraints:
    - digital_spi requires asil_b or asil_d
    - j1939 requires can_bitrate >= 250kbps

  Impact Analysis (asil_d vs qm):
    Flash: +12,480 bytes (+26%) — additional safety monitors
    WCET:  +180μs (+21%) — runtime diagnostic checks
    Stack: +256 bytes (+25%) — redundant computation buffers
```

### Diff View

**Audience:** Anyone reviewing changes
**Purpose:** Understand what changed between versions

```bash
torc inspect --view diff v1.1.0..v1.2.0
```

Shows structural changes to the graph: added/removed/modified nodes, changed contracts, changed resource bounds. Unlike textual diffs, this operates on the semantic graph — a refactoring that changes internal structure without changing interfaces or behavior shows as "no semantic change" even if the underlying graph is substantially different.

## Torc Studio

Torc Studio is the graphical IDE for human interaction with Torc programs. It provides:

- All projection views in an integrated UI
- Live graph visualization with zoom, pan, and hierarchical navigation
- Contract editor (for humans to add or modify requirements)
- Verification dashboard showing proof status in real-time
- Resource budget monitor with target-specific visualization
- Provenance explorer with timeline and blame views
- Side-by-side view for comparing variants or versions

Torc Studio is the primary interface through which humans exercise oversight of AI-generated Torc programs. It is designed for inspection and review, not for direct graph editing (though contract modification and annotation are supported).

## Machine-Readable Reports

Every view can be exported as a machine-readable report for integration with external tools:

```bash
torc inspect --view contracts --export json > contracts.json
torc inspect --view resources --export csv > resources.csv
torc inspect --view provenance --export spdx > sbom.spdx.json
torc verify --report iso-26262 --export pdf > verification-report.pdf
```
