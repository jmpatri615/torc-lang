# 11. Interoperability and FFI

## The Interop Problem

Torc exists in a world dominated by C, C++, Rust, Python, and Java. No new language succeeds without the ability to call existing code and be called by existing code. Torc's interop strategy must address two fundamental challenges:

1. **Torc → Foreign:** Calling external libraries, OS APIs, device drivers, and legacy code that will never be rewritten in Torc.
2. **Foreign → Torc:** Allowing existing systems to call Torc-generated computation modules, enabling incremental adoption.

## The FFI Bridge Architecture

The Torc FFI is not a simple function-call interface. It is a **bridge** that mediates between Torc's rich contract-and-proof world and the unverified world of foreign code.

```
┌──────────────────────┐     ┌─────────────────┐     ┌──────────────────────┐
│    Torc Graph        │     │   FFI Bridge     │     │   Foreign Code       │
│                       │     │                  │     │                      │
│  Verified contracts   │────▶│  Runtime checks  │────▶│  No contracts        │
│  Linear types         │     │  ABI adaptation  │     │  Manual memory mgmt  │
│  Effect tracking      │     │  Memory safety   │     │  Unchecked effects   │
│  Proof obligations    │     │  Effect barrier   │     │  Undefined behavior  │
│                       │◀────│  Result wrapping  │◀────│                      │
└──────────────────────┘     └─────────────────┘     └──────────────────────┘
```

The bridge inserts runtime checks at the boundary to enforce contracts that cannot be statically proven about foreign code. This is the one place in Torc where runtime checking is the norm rather than the exception.

## Calling C from Torc

### Step 1: Declare the Foreign Interface

Foreign functions are described as annotated graph nodes with `FFICall` kind:

```toml
# ffi/libc-math.ffi.toml

[foreign-library]
name = "libm"
language = "C"
abi = "C"
header = "math.h"
link = "m"

[[functions]]
name = "sin"
c-signature = "double sin(double)"
torc-contract = """
    input: Float<64> where is_finite(value)
    output: Float<64> where value >= -1.0 && value <= 1.0
    effects: Pure
    time: <= 100ns @ x86_64-generic  # Conservative estimate
"""
trust-level = "platform"           # Trust the platform math library

[[functions]]
name = "malloc"
c-signature = "void* malloc(size_t)"
torc-contract = """
    input: USize where value > 0
    output: Nullable<RawPtr>
    effects: Alloc<HEAP>
    failure: null -> AllocationFailed
"""
trust-level = "unsafe"             # Requires explicit opt-in

[[functions]]
name = "printf"
c-signature = "int printf(const char*, ...)"
torc-contract = """
    effects: IO<STDOUT>
"""
trust-level = "unsafe"             # Variadic, format string risks
excluded = true                    # Not available unless explicitly enabled
```

### Step 2: Generate the Bridge

```bash
torc ffi bridge --from-c ffi/libc-math.ffi.toml
```

This generates a Torc graph module containing wrapper nodes for each declared foreign function. The wrappers:

1. Validate preconditions at runtime (since foreign code doesn't carry proofs)
2. Adapt data layout to the target ABI (struct packing, endianness, alignment)
3. Handle the foreign call (set up stack frame, call through function pointer)
4. Validate postconditions on the return value
5. Wrap the result in Torc types (including converting null pointers to `Option::None`)

### Step 3: Use in Torc Graphs

The AI constructing a Torc program uses FFI nodes like any other node, but they carry an `FFI` effect that propagates through the graph. The verification engine knows that contracts on FFI nodes are checked at runtime, not proven statically, and reports this in verification summaries.

## Exposing Torc to C

### Step 1: Mark Exported Interfaces

In `torc.toml`:

```toml
[ffi.exports]
functions = [
    { torc-name = "pid_compute", c-name = "torc_pid_compute", abi = "C" },
    { torc-name = "safety_check", c-name = "torc_safety_check", abi = "C" },
]
```

### Step 2: Generate C Headers

```bash
torc ffi bridge --to-c
```

Produces:

```c
/* Auto-generated by Torc FFI Bridge — do not edit */
/* Module: motor-controller v1.2.0 */
/* Target: arm-cortex-m4f */

#ifndef TORC_MOTOR_CONTROLLER_H
#define TORC_MOTOR_CONTROLLER_H

#include <stdint.h>

typedef struct {
    float kp;
    float ki;
    float kd;
    float out_min;
    float out_max;
    float integrator_limit;
} torc_pid_config_t;

typedef struct {
    float integral;
    float prev_error;
    float prev_measurement;
} torc_pid_state_t;

typedef struct {
    float output;
    torc_pid_state_t state;
} torc_pid_result_t;

/**
 * PID controller computation.
 *
 * Contracts (enforced internally):
 *   Pre:  setpoint and measurement are finite
 *         dt > 0.0 && dt <= 1.0
 *         config gains are finite and non-negative
 *   Post: output in [config.out_min, config.out_max]
 *         state.integral in [-config.integrator_limit, config.integrator_limit]
 *
 * WCET: 8μs @ 168MHz Cortex-M4
 * Stack: 128 bytes
 * Heap: none
 */
torc_pid_result_t torc_pid_compute(
    float setpoint,
    float measurement,
    float dt,
    torc_pid_state_t state,
    torc_pid_config_t config
);

#endif
```

The generated C code includes contract documentation as comments, making the interface self-documenting for C consumers.

## Rust Interoperability

Rust interop is a higher priority than C++ because Rust's ownership model aligns naturally with Torc's linear types:

```bash
# Import a Rust crate as Torc dependency
torc ffi bridge --from-rust path/to/Cargo.toml --crate-name my_crate

# Export Torc module for use in Rust
torc ffi bridge --to-rust
```

The Rust bridge can map more Torc concepts than the C bridge:

| Torc Concept | Rust Mapping |
|---------------|-------------|
| `Linear<T>` | Owned `T` (move semantics) |
| `Shared<T>` | `&T` (shared reference) |
| `Unique<T>` | `&mut T` (unique reference) |
| `Option<T>` | `Option<T>` |
| `Variant<...>` | `enum` |
| `Vec<T>` | `Vec<T>` (with capacity tracking) |
| Refinement predicates | `debug_assert!` in debug, elided in release |

## C++ Interoperability

C++ interop goes through C: Torc generates `extern "C"` wrappers. Direct C++ interop (name mangling, vtables, exceptions, templates) is deferred to a future version due to the complexity and platform-specific nature of C++ ABI.

## Trust Levels

Every FFI interface has an explicit trust level:

| Level | Meaning | Runtime Checks | Verification |
|-------|---------|----------------|--------------|
| `verified` | Foreign code has been independently verified | Minimal | Full proof chain |
| `platform` | Trusted platform library (libc, libm, OS kernel) | Pre/post checks | Assumed correct |
| `audited` | Code reviewed by humans, not formally verified | Full boundary checks | Contracts assumed |
| `unsafe` | Unverified external code | Full checks + sandboxing | No assumptions |

The trust level determines how aggressively the bridge checks contracts at runtime and how the verification engine accounts for FFI calls in its proof chain.

```toml
# Project-level trust policy
[ffi.trust-policy]
allow-unsafe = false                # Reject unsafe FFI entirely
require-audited = true              # All FFI must be at least audited
platform-trusted = ["libc", "libm", "libpthread"]  # Auto-trust these
```

## Data Marshaling

Data crossing the FFI boundary must be marshaled between Torc's internal representation and the foreign ABI's expected layout:

- **Primitive types:** Direct mapping (Torc `Int<32, Signed>` = C `int32_t`)
- **Structs:** Layout computed to match target ABI (padding, alignment, field order)
- **Strings:** UTF-8 with null terminator for C compatibility
- **Arrays:** Pointer + length pair for C, slice for Rust
- **Opaque types:** Passed as opaque pointers with explicit lifetime tracking

The marshaling code is generated automatically by `torc ffi bridge` and is included in the verification scope — the bridge itself is verified to correctly translate between representations.
