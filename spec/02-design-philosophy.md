# 2. Design Philosophy and Principles

## The Seven Principles

### Principle 1: Graphs, Not Text

Programs are directed graphs of typed computation nodes connected by data edges. There is no source text, no file-per-module convention, no character encoding to argue about. The canonical representation is a binary-serialized graph format (`.trc` — Torc Graph).

**Rationale:** Text is a serialization format optimized for human eyes. AI systems operate on structured data. Forcing AI to generate and parse text is an unnecessary round-trip through human representation. A graph is the natural structure of computation — nodes are operations, edges are data dependencies.

**Practical consequence:** There is exactly one representation of any program. No formatting debates, no style guides, no linter configurations. Two programs are equal if and only if their graphs are isomorphic.

### Principle 2: Parallel by Default, Sequential by Exception

Every node in the computation graph is eligible for parallel execution unless it has an explicit data dependency on another node. Sequencing is expressed through dependency edges, not through textual ordering.

**Rationale:** Real hardware is parallel. Memory buses, execution units, I/O controllers — all operate concurrently. Sequential execution is the special case, not the default. Traditional languages invert this reality because humans think in sequences.

**Practical consequence:** The materialization engine is free to schedule any topologically valid ordering of the computation graph. This enables automatic exploitation of instruction-level parallelism, task-level parallelism, and data-level parallelism without the programmer (AI or otherwise) explicitly managing threads, SIMD lanes, or async runtimes.

### Principle 3: Contracts, Not Just Types

Every computation node carries not just a type signature but a full contract: preconditions, postconditions, resource bounds (time, memory, energy), effect declarations, and failure modes. These contracts are machine-checkable and are verified during materialization.

**Rationale:** In safety-critical systems, knowing that a function returns an `int` is almost useless. Knowing that it returns a value in `[0, 4095]`, completes within 50μs on the target hardware, allocates no heap memory, touches no shared state, and is monotonically increasing with respect to its first argument — that's useful. Torc makes this the baseline expectation, not an aspirational goal.

**Practical consequence:** "Testing" in the traditional sense largely disappears. The proof obligations embedded in contracts are discharged by the verification engine during materialization. What remains is validation — confirming that the contracts themselves correctly express the intended behavior.

### Principle 4: Materialization, Not Compilation

Building a Torc program is a constraint satisfaction problem, not a syntax-directed translation. The materialization engine takes as input the program graph and a target platform model (describing the hardware, OS, ABI, and runtime), and produces an executable by solving for a mapping that satisfies all contracts, resource bounds, and platform constraints simultaneously.

**Rationale:** Traditional compilation is a linear pipeline: parse → type-check → optimize → emit code. Each stage operates with limited knowledge of the others. Materialization is holistic — the engine knows the program's semantic intent, its correctness requirements, and the target's capabilities all at once, enabling globally optimal decisions.

**Practical consequence:** The same program graph can materialize to radically different executables on different targets. A sorting algorithm might become a merge sort with explicit NEON vectorization on ARM64, a radix sort using AVX-512 on x86_64, or a bitonic sort network on an FPGA. The intent ("sort this data with these properties") is the same; the realization is target-appropriate.

### Principle 5: Provenance is Permanent

Every node, edge, and annotation in a Torc graph carries a provenance record: who created it (which AI model, which version), when, why (linked to a requirement, optimization decision, or design rationale), and what it replaced (full edit history). Provenance is immutable and unforgeable.

**Rationale:** When a system is too complex for humans to read directly, the ability to trace *why* a decision was made becomes critical. Provenance enables audit trails for safety certification, blame analysis for bugs, and trust calibration for AI-generated code.

**Practical consequence:** Regulatory compliance (ISO 26262, DO-178C, IEC 62443) can be addressed through provenance inspection rather than code review. The question shifts from "does this code look correct?" to "was this code generated by a trusted process with verified requirements traceability?"

### Principle 6: Interop is Non-Negotiable

Torc must call and be called by existing C, Rust, and C++ code. The real world runs on existing libraries, device drivers, OS kernels, and protocol stacks. A language that cannot interoperate is a toy.

**Rationale:** No language succeeds in isolation. Rust's adoption was accelerated by excellent C FFI. Torc must do the same, and go further — automatically generating binding layers and verifying that foreign function contracts are respected at the boundary.

**Practical consequence:** The `torc ffi bridge` tool generates C-compatible headers and binding code from Torc graph modules, and generates Torc graph wrappers around existing C libraries. At the FFI boundary, the verification engine inserts runtime checks for contracts that cannot be statically proven about foreign code.

### Principle 7: Humans Must Be Able to Understand

The observability layer is a core component of the language, not an afterthought. Every Torc program must be projectable into human-comprehensible representations: dataflow diagrams, contract summaries, resource budget tables, dependency trees, and pseudo-code approximations.

**Rationale:** Opacity without observability is irresponsible. AI-native does not mean human-excluded. Engineers must be able to inspect, audit, and build trust in systems they didn't write and can't read natively. The observability layer is the bridge.

**Practical consequence:** `torc inspect` launches an interactive exploration environment. `torc verify --report` generates human-readable verification reports. These are not debugging tools bolted on later — they are integral to the language specification and every compliant Torc implementation must provide them.

## What Torc Explicitly Rejects

- **Syntax.** There are no keywords, operators, or grammar rules. The graph structure *is* the program.
- **File-based organization.** Modules are subgraphs, not files. A project's logical structure is independent of filesystem layout.
- **Implicit behavior.** No implicit conversions, no default arguments, no operator overloading, no hidden control flow. Every computation is an explicit node.
- **Global mutable state.** All state is explicitly threaded through the graph as data edges. There is no ambient environment, no global variables, no hidden side channels.
- **Undefined behavior.** Every possible execution is defined. The type system and contract system make undefined behavior unrepresentable.
